#!/usr/bin/php -q
<?php
/*******************************************************************\
*	Gemeinschaft - asterisk cluster gemeinschaft
* 
* $Revision$
* 
* Copyright 2015, Markus Neubauer, Zeitblomstr. 29, 81735 MÃ¼nchen, Germany,
* http://www.std-soft.com/
* Markus Neubauer <markus.neubauer@email-online.org>
* 
* 
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
* as published by the Free Software Foundation; either version 2
* of the License, or (at your option) any later version.
* 
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
* MA 02110-1301, USA.
\*******************************************************************/


define('GS_VALID', true); // arriving nativ here

require_once( dirName(__FILE__) .'/../inc/conf.php' );
$CARDDAV_LOG = 'cloud_connector.log';
$FIFO = '';
$process_name = 'vcard-checker';
include_once( GS_DIR .'inc/log.php' );

if (defined('STDIN' )) @fClose(STDIN );
if (defined('STDOUT')) @fClose(STDOUT);
if (defined('STDERR')) @fClose(STDERR);

include_once( GS_DIR .'lib/yadb/yadb.php' );
include_once( GS_DIR .'inc/gs-lib.php' );
require_once( GS_DIR .'lib/carddav/CardDAV.php' );
require_once( GS_DIR .'lib/XML/xml2array.php' );
require_once( GS_DIR .'inc/db_connect.php' );

$CLOUD_MSG = '';

// vCard DAV connect
function gs_vcards_connect( $url=null, $login=null, $pass=null ) {
  global $CARDDAV_LOG, $FIFO, $CLOUD_MSG, $sudo_user;

	if (! class_exists('carddav_backend')) {
		$CLOUD_MSG = 'This system does not support carddav (lib CardDav.php missing)!';
		gs_log( GS_LOG_FATAL, getmypid() . ': ' . $CLOUD_MSG, $CARDDAV_LOG, $FIFO );
		return false;
	}

	$carddav_conn = new carddav_backend($url);
	$carddav_conn->set_auth($login, $pass);

	if ( $carddav_conn->check_connection() ) {
		$CLOUD_MSG = $sudo_user . ': connected to CardDAV '. $url .' for user ' . $login;
		gs_log(GS_LOG_DEBUG, getmypid() . ': ' . $CLOUD_MSG, $CARDDAV_LOG, $FIFO );
		return $carddav_conn;
	} else {
		$CLOUD_MSG = $sudo_user . ': Can not connect to cloud, check url, and login/password.';
		gs_log(GS_LOG_FATAL, getmypid() . ': ' . $CLOUD_MSG, $CARDDAV_LOG, $FIFO );
		return false;
	}
}

// update gs records
function gs_vcard_update( $vcr, $head, $vcard, $lvc=array() ) {
  global $CARDDAV_LOG, $FIFO, $DB, $CANONIZE_INTL_PREFIX, $CANONIZE_COUNTRY_CODE, $CANONIZE_NATL_PREFIX, $USER_ID;

	$last_modified = date("Y-m-d H:i:s", strtotime( $head['d:propstat']['d:prop']['d:getlastmodified'] ));
	$etag = str_replace('"', '', $head['d:propstat']['d:prop']['d:getetag']);

	// remove phone numbers on existing vcards -> update is difficult due to aligment with name/phone number
	if ( ! empty($lvc) ) {
		$DB->execute('DELETE FROM `pb_prv` WHERE `card_id`=' . $lvc['id']);
		$DB->execute('DELETE FROM `pb_prv_category` WHERE `card_id`=' . $lvc['id']);
	}
	else {
		$DB->execute('INSERT INTO `pb_cloud_card` ' .
				' (`cloud_id`,`vcard_id`,`etag`,`vcard`,`last_modified`) ' .
				' VALUES(' . $vcr['id'] . ',\'' . $head['vcard_id'] . '\',\'' . $etag . '\',\'' . mysql_real_escape_string($vcard) . '\',\'' . $last_modified . '\')');
		$lvc = $DB->execute( 'SELECT `id`,`cloud_id`,`vcard_id`,`etag`,`last_modified`' .
				' FROM `pb_cloud_card` ' .
				' WHERE `cloud_id`=' . $vcr['id'] . 
					' and `vcard_id`=\'' . $head['vcard_id'] . '\' LIMIT 1'
				)->fetchRow();
	}

	$tmp_vcard = explode("\n", $vcard);

	$n = array();
	$acat = array();
	$aparam = array();
	$fn   = '';
	$ln   = '';
	foreach ( $tmp_vcard as $value ) {
		if ( empty( $value ) ) continue;


		$pos = strpos($value, ':');
		$elem = trim(substr($value, $pos + 1 ));
		$aparam = explode(';', substr($value, 0, $pos));
		$key  = strtoupper( array_shift( $aparam ) );

		// we need only name, category and tel type records for the phone book
		if ( 'N' != $key && 'TEL' != $key && 'CATEGORIES' != $key ) continue;

		if     ( 'N' == $key ) {
			// reverse the array N for the phones display
			$aname = explode(';', $elem);
			$ln = array_shift( $aname );
			for ($i = count($aname); $i >= 0; $i--) {
				if ( empty($aname[$i]) ) continue;
				$fn .= ' ' . $aname[$i];
			}
			$fn = ltrim( $fn );
			if ( empty( $ln) ) { $ln = $fn; $fn=''; }
		}

		elseif ( 'TEL' == $key ) {

			// do not canonize on sip strings
			if ( strpos($elem, '@') === false ) {

				if ( '+' == substr($elem, 0, 1) ) 
					$elem = GS_CANONIZE_INTL_PREFIX . substr($elem, 1);

				$number = preg_replace('/\D/', '', $elem);

				if ( GS_CANONIZE_INTL_PREFIX . GS_CANONIZE_COUNTRY_CODE == substr($number, 0, strlen(GS_CANONIZE_INTL_PREFIX . GS_CANONIZE_COUNTRY_CODE) ) ) 
					$number = GS_CANONIZE_NATL_PREFIX . substr($number, strlen(GS_CANONIZE_INTL_PREFIX . GS_CANONIZE_COUNTRY_CODE));
			}
			else $number = $elem;

			// add number to array, making it singular
			if ( ! isset($n[$number]) ) $n[$number] = array( 'type' => '', 'pref' => 99 );

			// add attributes to the number
			foreach ( $aparam as $param ) {
				if ( empty($param) ) continue;
				$k2 = explode('=', strtoupper( $param ));
				$k2[1] = str_replace('"', '', $k2[1]);
				if ( 'TYPE' == $k2[0] ) {
					if ( $k2[1] == 'MAIN' ) $n[$number]['pref'] = 1;
					if ( $k2[1] == 'PREF' ) $n[$number]['pref'] = 1;
					else $n[$number]['type'] .= strtolower( $k2[1] ) . ',';
					if ( strpos($k2[1], 'PREF' ) !== false ) $n[$number]['pref'] = 1;
				}
				elseif ( 'PREF' == $k2[0] ) $n[$number]['pref'] = (int)$k2[1];
			}
			$n[$number]['type'] = rtrim($n[$number]['type'], ',');
			if ( $n[$number]['pref'] < 1 ) $n[$number]['pref'] = 1;
		}
		elseif ( 'CATEGORIES' == $key ) $acat = explode( ',', $elem );
	}

	// loop over phone numbers
	foreach ( $n as $number => $param ) {

		$prc=false;
		// check_duplicates from within a vcard -> try to avoid duplicates, the latest wins
		if ( $prc = $DB->execute('SELECT `id` FROM `pb_prv` WHERE `user_id`=' . $USER_ID . ' AND `firstname`=\'' . $fn . '\' AND `lastname`=\'' . $ln . '\' AND `number`=\'' . $number . '\' AND `card_id`=0 LIMIT 1')->fetchRow() )
			$DB->execute('DELETE FROM `pb_prv` WHERE `id`=' . $prc['id']);
		// net could probably changed to an update 
		elseif ( $prc = $DB->execute('SELECT `id` FROM `pb_prv` WHERE `user_id`=' . $USER_ID . ' AND `firstname`=\'' . $fn . '\' AND `lastname`=\'' . $ln . '\' AND `number`=\'' . $number . '\' LIMIT 1')->fetchRow() )
			$DB->execute('DELETE FROM `pb_prv` WHERE `id`=' . $prc['id']);

		// add a phone record
		$DB->execute('INSERT INTO `pb_prv` ' .
			' (`user_id`,`firstname`,`lastname`,`number`,`ptype`,`pref`,`card_id`) ' .
			' VALUES(' . $USER_ID .',\'' . $fn .'\',\'' . $ln .'\',\'' . $number .'\',\'' . $param['type'] .'\',' . $param['pref'] . ',' . $lvc['id'] . ')');

		// loop over categories
		if ( ! empty( $acat) ) {
			$prc = $DB->execute( 'SELECT `id` FROM `pb_prv` WHERE `user_id`=' . $USER_ID . ' and `firstname`=\'' . $fn  . '\' and `lastname`=\'' . $ln  . '\' and `number`=\'' . $number . '\' and `ptype`=\'' . $param['type'] . '\' and `card_id`=' . $lvc['id'] . ' LIMIT 1')->fetchRow();
			foreach ( $acat as $cat ) {
				if ( empty($cat) ) continue;
				if ( ! $crc = $DB->execute( 'SELECT `id` FROM `pb_category` WHERE `user_id`=' . $USER_ID . ' and `category`=\'' . $cat  . '\'')->fetchRow() ) {
					// insert rec
					$DB->execute('INSERT INTO `pb_category` ' .
						' (`user_id`,`category`) ' .
						' VALUES(' . $USER_ID .',\'' . $cat .'\')');
					$crc = $DB->execute( 'SELECT `id` FROM `pb_category` WHERE `user_id`=' . $USER_ID . ' and `category`=\'' . $cat  . '\' LIMIT 1')->fetchRow();
				}
				// correct xref
				$DB->execute('INSERT INTO `pb_prv_category` ' .
					' (`user_id`,`cat_id`,`card_id`,`prv_id`) ' .
					' VALUES(' . $USER_ID .',' . $crc['id'] .',' . $lvc['id'] .',' . $prc['id'] . ')');
			}
		}
	}

}


// fetch vcards for a cloud entry
function gs_user_vcards_update( $vcr ) {
  global $CARDDAV_LOG, $FIFO, $DB, $CLOUD_MSG, $USER_ID;
	$vc_add = 0;
	$vc_mod = 0;
	$vc_del = 0;
	$vc_seen = 0;

	$carddav_conn = gs_vcards_connect( $vcr['url'], $vcr['login'], $vcr['pass'] );
	if ( ! is_object( $carddav_conn ) || $carddav_conn === false ) {
		return false;
	}

	$a = new XMLThing();
	$vchead = $a->parse($carddav_conn->get(false,true));
	$vchead = $vchead['d:multistatus']['d:response'];
	$head   = array_shift ( $vchead );
	$CLOUD_MSG = '';

	// skip rest if not modified between, depending on header etag or lastmodified
	if ( isset( $head['d:propstat']['d:prop']['cs:getctag'] ) ) {
		// ref etag: https://tools.ietf.org/html/rfc6352
		$last_ctag = str_replace('"', '', $head['d:propstat']['d:prop']['cs:getctag']);
		if ( $last_ctag == $vcr['last_ctag'] ) {
			$CLOUD_MSG =  'no update, cloud last ctag: '. $last_ctag;
			gs_log(GS_LOG_DEBUG, getmypid() . ': ' . $CLOUD_MSG, $CARDDAV_LOG, $FIFO );
			return true;
		}
	} else  $last_ctag = '';

	if ( isset($head['d:propstat']['d:prop']['d:getlastmodified']) ) {
		$last_modified = date("Y-m-d H:i:s", strtotime( $head['d:propstat']['d:prop']['d:getlastmodified'] ));
		if ( $last_modified <= $vcr['last_remote_modified'] ) {
			$CLOUD_MSG = 'no update, cloud last modified: '. $last_modified;
			gs_log(GS_LOG_DEBUG, getmypid() . ': ' . $CLOUD_MSG, $CARDDAV_LOG, $FIFO );
			return true;
		}
	} else $last_modified = $vcr['modified'];

	gs_log(GS_LOG_DEBUG, getmypid() .': updating..., last modified='. $last_modified, $CARDDAV_LOG, $FIFO );
	// update ctag and last_modified immed
	$DB->execute('UPDATE `pb_cloud` SET `ctag`=\'' . $last_ctag . '\', `last_remote_modified`=\'' . $last_modified . '\' WHERE `id`=' . $vcr['id']);

	// get unseen records
	gs_log(GS_LOG_DEBUG, getmypid() .': fetch unseen', $CARDDAV_LOG, $FIFO );
	$unseen=array();
	$unrc = $DB->execute('SELECT `id`, `vcard_id`,`etag`, `last_modified` FROM `pb_cloud_card` WHERE `cloud_id`=' . $vcr['id']);
	while ( $urc = $unrc->fetchRow() ) {
		$unseen[$urc['vcard_id']] = array(
			'id'		=> $urc['id'],
			'etag'		=> $urc['etag'],
			'last_modified' => $urc['last_modified']
			);
	}
	if ( empty($unseen) ) gs_log(GS_LOG_DEBUG, getmypid() .': no unseen, adding ...', $CARDDAV_LOG, $FIFO );

	gs_log(GS_LOG_DEBUG, getmypid() .': updating vcards...', $CARDDAV_LOG, $FIFO );

	// iterate through all of them
	for ($i = 0; $i < count($vchead); $i++) {

		$vcard_id=str_replace('.vcf', null, substr($vchead[$i]['d:href'], strrpos($vchead[$i]['d:href'], '/') + 1) );

		$vchead[$i]['vcard_id'] =  $vcard_id;

		$vc_seen += 1;
		// check for existing vcard
		if ( isset($unseen[$vcard_id]) ) {
			$lvc = $unseen[$vcard_id];
			// avoid deleting
			unset($unseen["$vcard_id"]);

			// skip if not modified
			$last_modified = date("Y-m-d H:i:s", strtotime( $vchead[$i]['d:propstat']['d:prop']['d:getlastmodified'] ));
			$last_etag = str_replace('"', '', $vchead[$i]['d:propstat']['d:prop']['d:getetag']);
			if ( $last_etag == $lvc['etag'] && $last_modified == $lvc['last_modified'] ) continue;

			$vc_mod += 1;
			gs_log(GS_LOG_DEBUG, getmypid() .': updating '. $vcard_id, $CARDDAV_LOG, $FIFO );

			$vchead[$i]['d:propstat']['d:prop']['d:getlastmodified'] = $last_modified;

			// modified remote get the new vcard
			$vcard = $carddav_conn->get_vcard($vcard_id . '.vcf');
			gs_vcard_update( $vcr, $vchead[$i], $vcard, $lvc );

		} else {
			// missing local add new vcard
			$vc_add += 1;
			gs_log(GS_LOG_DEBUG, getmypid() .': adding '. $vcard_id, $CARDDAV_LOG, $FIFO );
			$vcard = $carddav_conn->get_vcard($vcard_id . '.vcf');
			gs_vcard_update( $vcr, $vchead[$i], $vcard );
		}
	}

	// delete no more existing recs
	foreach ($unseen as $vcard_id => $value) {
		$vc_del += 1;
		gs_log(GS_LOG_DEBUG, getmypid() .': deleting '. $vcard_id, $CARDDAV_LOG, $FIFO );
		$DB->execute('DELETE FROM `pb_prv_category` WHERE `user_id`=' . $USER_ID . ' and `card_id`=' . $value['id']);
		$DB->execute('DELETE FROM `pb_prv` WHERE `user_id`=' . $USER_ID . ' and `card_id`=' . $value['id']);
		$DB->execute('DELETE FROM `pb_cloud_card` WHERE `id`=' . $value['id']);
	}

	// clean up categories
	$rs2 = $DB->execute(  'DELETE c FROM `pb_category` AS c ' . 
				 ' LEFT JOIN `pb_prv_category` AS p ' .
					' ON  c.id = p.cat_id ' . 
				     ' WHERE  c.user_id = ' . $USER_ID .
				       ' AND  p.id IS NULL'
				);
	$CLOUD_MSG = $vc_seen . ' seen, ' . $vc_mod . ' modified, ' . $vc_add . ' added, ' . $vc_del . ' deleted';
	gs_log(GS_LOG_DEBUG, getmypid() . ': ' . $CLOUD_MSG, $CARDDAV_LOG, $FIFO );

	return true;
}

$DB = gs_db_master_connect();


// remain in loop, doing a record time by time (avoid race cond in dup exec)
while ( true ) {
	$CLOUD_MSG = '';
	$vcrc = @ $DB->execute(
		'SELECT
		`id`, `user_id`, `url`, `login`, cast(des_decrypt(`pass`,`login`) as char(16)) as pass, `frequency`, `ctag`, 
		`last_remote_modified`, `modified`, `error_count`, `public`
		FROM `pb_cloud` 
		WHERE `next_poll` < NOW() AND `active`=1 ORDER BY `next_poll`
		LIMIT 1'
		);
	if ( $vcr = $vcrc->fetchRow() ) {
		$usrc = $DB->execute('SELECT `user` FROM `users` WHERE `id`=' . $vcr['user_id'] . ' LIMIT 1');
		$urc =  $usrc->fetchRow();
		$sudo_user = $urc['user'];
		gs_log(GS_LOG_NOTICE, getmypid() .': Checking vCards for ' . $sudo_user . ': '. $vcr['login'] . ': ' .  $vcr['url'], $CARDDAV_LOG, $FIFO );

	} else break; // the loop, nothing to be done anymore
	

	// update next check immediately to avoid concurrent execs in timeout situations
	$hdm2text = array(
		'h' => 'hour',
		'd' => 'day', 
		'm' => 'month' 
	);
	$period = substr($vcr['frequency'], -1);
	$freq = substr($vcr['frequency'], 0, -1);
	if ( $freq > 1 ) $more = 's'; 
	else $more = '';

	$next_poll = date_format(date_add( date_create(), DateInterval::createFromDateString("$freq $hdm2text[$period]" . "$more") ), "Y-m-d H:i:s");

	$DB->execute('UPDATE `pb_cloud` SET `next_poll`=\'' . $next_poll . '\', `message`=\'Update in progress...\' WHERE `id`=' . $vcr['id']);

	// if its a public record we are goig to write for user_id = 0 (which should(!) not exist)
	if ( $vcr['public'] ) $USER_ID = 1;
	else $USER_ID = $vcr['user_id'];

	$unset_active='';

	if ( gs_user_vcards_update( $vcr )  === true ) {

		// all went ok
		gs_log(GS_LOG_NOTICE, getmypid() .': Check vCards completed normal for ' . $sudo_user . '.', $CARDDAV_LOG, $FIFO );
		$CLOUD_MSG     = 'OK - ' . $CLOUD_MSG;
		$error_counter = ', `error_count`=0 ';

	} else {

		// any failure
		$error_counter=', `error_count`=`error_count`+1 ';
		$CLOUD_MSG = getmypid() . ': ';
		if ( $vcr['error_count'] = 4 ) {
			// deactivate record
			$unset_active = ', `active`=0 ';
			$CLOUD_MSG .= 'Set inactive. ';
		};
		$CLOUD_MSG .= 'Check vCards failed for ' . $vcr['login'] . ': ' . $vcr['url'];
		gs_log(GS_LOG_WARNING, $sudo_user . ': ' . $CLOUD_MSG, $CARDDAV_LOG, $FIFO );
		// increment error counter
	}

	// inform on user display
	$DB->execute('UPDATE `pb_cloud` SET `message` = CONCAT_WS(\' \', ' .
				'\'' . $CLOUD_MSG . '\',\', last check: \', `modified` ) ' .
				$error_counter . $unset_active .
                     ' WHERE `id` = ' . $vcr['id']);
}

?>
