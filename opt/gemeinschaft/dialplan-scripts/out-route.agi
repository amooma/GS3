#!/usr/bin/php -q
<?php
/*******************************************************************\
*            Gemeinschaft - asterisk cluster gemeinschaft
* 
* $Revision$
* 
* Copyright 2007, amooma GmbH, Bachstr. 126, 56566 Neuwied, Germany,
* http://www.amooma.de/
* Stefan Wintermeyer <stefan.wintermeyer@amooma.de>
* Philipp Kempgen <philipp.kempgen@amooma.de>
* Peter Kozak <peter.kozak@amooma.de>
* 
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
* as published by the Free Software Foundation; either version 2
* of the License, or (at your option) any later version.
* 
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
* MA 02110-1301, USA.
\*******************************************************************/

define( 'GS_VALID', true );  /// this is a parent file
require_once( dirName(__FILE__) .'/../inc/conf.php' );
require_once( GS_DIR .'inc/agi-fns.php' );
require_once( GS_DIR .'inc/pcre_check.php' );
include_once( GS_DIR .'lib/yadb/yadb.php' );
include_once( GS_DIR .'lib/yadb/yadb_mptt.php' );

ini_set('implicit_flush', 1);
ob_implicit_flush(1);

error_reporting(0);


function _user_groups_get( $user_id, $with_0=null )
{
	global $db;
	
	if (! $db) return false;
	$user_id = (int)$user_id;
	
	$group_id = (int)$db->executeGetOne( 'SELECT `group_id` 
		FROM `users` WHERE `id`='. $user_id
		);
	
	# get nested groups
	#
	$member_groups = array();
	if ($with_0 !== false) {
		$member_groups[] = $with_0;
	}
	if ($group_id > 0) {
		$mptt = new YADB_MPTT($db, 'user_groups', 'lft', 'rgt', 'id');
		$path = @$mptt->get_path_to_node( $group_id, true );
		if (! is_array($path))
			return false;
		
		foreach ($path as $group) {
			$member_groups[] = $group['id'];
		}
	}
	
	return $member_groups;
}


function _no_more_routes( $idx=1 )
{
	gs_agi_set_variable( 'r_'.$idx.'_dial', '' );
	die();
}


$number = ($argc > 1) ? trim($argv[1]) : '';
if ($number == '') {
	gs_agi_verbose("### Empty number");
	echo "HANGUP\n";
	_no_more_routes();
}

$is_sub_system = ($argc > 2) ? strToLower(trim($argv[2])) : '';
$is_sub_system = ($is_sub_system=='1' || $is_sub_system=='yes');

//$user_cid_num = ($argc > 3) ? preg_replace('/[^0-9]/', '', $argv[3]) : '';
$user_cid_num = ($argc > 3) ? trim($argv[3]) : '';
# "anonymous" is a valid caller ID number in SIP

# caller ID (= extension) of the user
if ($user_cid_num == '') {
	$user_cid_num = '0';  # main number on a PtP interface
}

$user_id = (int)trim($argv[4]);


include_once( GS_DIR .'inc/db_connect.php' );


$qualify_cid = true;

if (gs_get_conf('GS_CANONIZE_OUTBOUND')) {
	
	include_once( GS_DIR .'inc/canonization.php' );
	//$canonical = new CanonicalPhoneNumber( $number );
	$canonical = new CanonicalPhoneNumber( substr($number,1) );
	$gateway_prefix = substr($number,0,1);
	
	if (@$canonical->is_call_by_call) {
		gs_agi_verbose("### $number has a call-by-call prefix");
		echo "HANGUP\n";
		_no_more_routes();
	}
	elseif (@$canonical->in_prv_branch) {
		$qualify_cid = false;
		if ($is_sub_system) {
			# allow to go to the outside
			gs_agi_verbose("### $number is in private branch but we are a sub-system");
			$number_dial = trim( @$canonical->dial );
		} else {
			gs_agi_verbose("### $number is in private branch and we are not a sub-system");
			/*
			# don't dial to the outside
			echo "HANGUP\n";
			_no_more_routes();
			*/
			# dial our extension
			$exten = trim( @$canonical->extn );
			if ($exten != '') {
				gs_agi_set_variable( '__is_from_gateway', '1' );
				$idx = 1;
				gs_agi_set_variable( 'r_'.$idx.'_dial', ('Local/'. $exten .'@to-internal-users') );
				gs_agi_set_variable( 'r_'.$idx.'_cid', $user_cid_num );
				_no_more_routes(++$idx);
			} else {
				gs_agi_verbose("### Empty number");
				echo "HANGUP\n";
				_no_more_routes();
			}
		}
	}
	else {
		$number_dial = $gateway_prefix.trim( @$canonical->dial );
	}
	
	if ($number_dial == '') {
		gs_agi_verbose("### Empty number");
		echo "HANGUP\n";
		_no_more_routes();
	}
	
} else {
	$number_dial = $number;
}


$db = gs_db_slave_connect();
if (! $db) die(1);

$user_groups = _user_groups_get( $user_id, 0 );
if (! is_array($user_groups)) $user_groups = array(0);
//$user_groups = array_merge(array(0), $user_groups);

$t = time();
$wd = strToLower(subStr(date('D', $t),0,2));
$hm = date('H:i', $t);

$rs = $db->execute(
'SELECT
	`pattern` `pat`,
	`user_grp_id` `ug_id`,
	`gw_grp_id_1` `gg1`, `gw_grp_id_2` `gg2`, `gw_grp_id_3` `gg3`,
	`lcrprfx`
FROM `routes` USE INDEX(`active_'.$wd.'`)
WHERE
	`active`=1 AND `d_'.$wd.'`=1 AND
	`h_from`<=\''.$hm.'\' AND `h_to`>=\''.$hm.'\'
ORDER BY `ord`'
);
// we can't use MySQL's REGEXP comparison because it does not understand
// all of PCRE syntax
$have_match = false;
$lcr_prefix = '';
while ($route = $rs->fetchRow()) {
	if (@preg_match( '/'.$route['pat'].'/', $number_dial )) {
		if (in_array((int)$route['ug_id'], $user_groups, true)) {
			$have_match = true;
			$lcr_prefix = $route['lcrprfx'];
			gs_agi_verbose( '### Matching route for "'. $number_dial .'" is "'. $route['pat'] .'", user group: '. ($route['ug_id'] == null ? 'any' : $route['ug_id']) );
			break;
		}
	}
}
if (! $have_match) _no_more_routes();

$gate_grps = array();
if ($route['gg1'] != 0) $gate_grps[] = (int)$route['gg1'];
if ($route['gg2'] != 0) $gate_grps[] = (int)$route['gg2'];
if ($route['gg3'] != 0) $gate_grps[] = (int)$route['gg3'];
unset($route);
if (count($gate_grps) < 1) _no_more_routes();

$gates = array();
$idx = 1;
foreach ($gate_grps as $ggrp_id) {
	
	$out_cid_num = $user_cid_num;
	if ($qualify_cid
	&&  ! in_array(strToLower($out_cid_num), array('anonymous', 'unknown', ''), true))  # no action for "anonymous"
	{
		$rs = $db->execute(
'SELECT `out_cid_search` `cid_s`, `out_cid_replace` `cid_r`, `name`
FROM `gate_grps`
WHERE `id`='. $ggrp_id
		);
		if (!($ggrp = $rs->fetchRow())) continue;
		
		$ggrp['cid_s'] = trim($ggrp['cid_s']);
		if ($ggrp['cid_s'] != ''
		&&  is_valid_pcre( '/'.$ggrp['cid_s'].'/', $ggrp['cid_r'] ))
		{
			$out_cid_num_qualified = preg_replace('/[^0-9+a-zA-Z\-_.]/', '',
				@preg_replace( '/'.$ggrp['cid_s'].'/', $ggrp['cid_r'], $out_cid_num ));
			$out_cid_num = $out_cid_num_qualified;
			gs_agi_verbose( '### Qualifying caller ID "'.$out_cid_num.'" -> "'.$out_cid_num_qualified.'" ('. ('s/'.$ggrp['cid_s'].'/'.$ggrp['cid_r'].'/') .') for gategroup "'. $ggrp['name'] .'"' );
			unset($out_cid_num_qualified);
		}
	}
	
	$rs = $db->execute(
'SELECT `type`, `name`, `dialstr`, `hw_port`
FROM `gates`
WHERE
	`grp_id`='. $ggrp_id .' AND
	`allow_out`=1
ORDER BY RAND()
LIMIT 9'
	);
	//while ($gate = $rs->fetchRow()) $gates[] = $gate;
	while ($gate = $rs->fetchRow()) {
		if ($lcr_prefix != '') {
			if (in_array($gate['type'], array('zap','misdn','woomera','capi'), true)) {
				gs_agi_verbose("### LCR prefix: $lcr_prefix for gateway ". $gate['name'] );
				$number_final = $lcr_prefix . $number_dial;
			} else {
				gs_agi_verbose("### LCR prefix $lcr_prefix ignored for non-hardware gateway ". $gate['name'] );
				$number_final = $number_dial;
			}
		} else {
			$number_final = $number_dial;
		}
		$dialstr = str_replace('{peer}', '{gateway}', $gate['dialstr']);  # backwards compatibility
		$dialstr = str_replace(
			array( '{number}'   , '{number:1}'            , '{gateway}'   , '{port}'          ),
			array( $number_final, substr($number_final,1) , $gate['name'] ,  $gate['hw_port'] ),
			$gate['dialstr']
		); //FIXME - do proper parsing instead of "{number:1}"
		$dialstr = preg_replace('/[^\x21-\x7E]/', '', $dialstr);
		if ($dialstr != '') {
			gs_agi_set_variable( 'r_'.$idx.'_dial', $dialstr );
			gs_agi_set_variable( 'r_'.$idx.'_cid', $out_cid_num );
			++$idx;
		}
	}
}
_no_more_routes($idx);


?>